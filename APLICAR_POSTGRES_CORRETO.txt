============================================
APLICAR CONFIGURAÇÕES POSTGRESQL (MÉTODO CORRETO)
Usar postgresql.auto.conf que tem prioridade
============================================

# 1. Editar o arquivo postgresql.auto.conf (tem prioridade sobre postgresql.conf)
docker exec -it cnpj_postgres bash -c "cat > /var/lib/postgresql/data/postgresql.auto.conf << 'CONF'
# Otimizações VPS (16GB RAM, 4 CPUs, NVMe SSD)
shared_buffers = '4GB'
effective_cache_size = '12GB'
work_mem = '40MB'
maintenance_work_mem = '1600MB'
max_worker_processes = 4
max_parallel_workers = 4
max_parallel_workers_per_gather = 2
random_page_cost = 1.1
effective_io_concurrency = 200
wal_buffers = '16MB'
max_wal_size = '2GB'
min_wal_size = '1GB'
checkpoint_completion_target = 0.9
autovacuum_max_workers = 2
autovacuum_naptime = '1min'
log_min_duration_statement = 1000
log_checkpoints = on
CONF
"

# 2. Reiniciar PostgreSQL
docker restart cnpj_postgres

# 3. Aguardar 30 segundos
sleep 30

# 4. Verificar TODAS as configurações
docker exec -i cnpj_postgres psql -U cnpj_user -d cnpj_db << 'EOF'
SELECT 
    name, 
    setting,
    unit,
    CASE 
        WHEN unit = '8kB' THEN pg_size_pretty((setting::bigint * 8192)::bigint)
        WHEN unit = 'kB' THEN pg_size_pretty((setting::bigint * 1024)::bigint)
        WHEN unit = 'MB' THEN setting || ' MB'
        ELSE setting || COALESCE(' ' || unit, '')
    END as valor_legivel
FROM pg_settings 
WHERE name IN (
    'shared_buffers', 
    'effective_cache_size', 
    'work_mem', 
    'maintenance_work_mem',
    'max_worker_processes',
    'max_parallel_workers',
    'random_page_cost',
    'effective_io_concurrency'
)
ORDER BY name;
EOF

============================================
VALORES ESPERADOS:
============================================
effective_cache_size     | 12 GB
max_parallel_workers     | 4
max_worker_processes     | 4
random_page_cost         | 1.1
shared_buffers           | 4096 MB
work_mem                 | 40 MB

============================================
